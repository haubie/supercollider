# Supercollider - syndef file format

## Synthdef v2 format

* synth-definition-file
  * int32 - four byte file type id containing the ASCII characters: "SCgf"
  * int32 - file version, currently 2.
  * int16 - number of synth definitions in this file (D).
  * [ synth-definition ] * D
    * pstring - the name of the synth definition
    * int32 - number of constants (K)
    * [float32] * K - constant values
    * int32 - number of parameters (P)
    * [float32] * P - initial parameter values
    * int32 - number of parameter names (N)
    * [ param-name ] * N
      * pstring - the name of the parameter
      * int32 - its index in the parameter array
    * int32 - number of unit generators (U)
    * [ ugen-spec ] * U
      * pstring - the name of the SC unit generator class
      * int8 - calculation rate
      * int32 - number of inputs (I)
      * int32 - number of outputs (O)
      * int16 - special index
      * [ input-spec ] * I
      * int32 - index of unit generator or -1 for a constant
      * if (unit generator index == -1)
      * int32 - index of constant
      * else
      * int32 - index of unit generator output
      * [ output-spec ] * O
      * int8 - calculation rate
    * int16 - number of variants (V)
    * [ variant-spec ] * V
      * pstring - the name of the variant
      * [float32] * P - variant initial parameter values

```elixir
defmodule SynthDef do
  defstruct ~w[
                name

                constant_count constant_values_list

                parameter_count parameter_values_list
                parameter_names_count parameter_names_list

                ugen_count ugen_specs_list

                varient_count varient_specs_list
              ]a

  @doc """
  Equivalent of SynthDef.new(name, ugenGraphFunc, rates, prependArgs, variants, metadata) in supercollider lang 
  
  The parameters are:
  - *name* - A String (i.e. "name"). This name will be used to refer to the SynthDef when creating a Synth based upon it, and should be unique.
  - *ugen_specs_list* - specifies how the def's UGens are interconnected.
  """
  def new(name, ugen_specs_list, rates \\ [], prependArgs \\ [], variants \\ [], metadata \\ []) do
    %__MODULE__{
      name: name,
      ugen_specs_list: ugen_specs_list,
      ugen_count: length(ugen_specs_list)
    }
  end

end

defmodule ParamName do
  defstruct ~w[
    name
    index
  ]a
end


{ |out|
    var outArray;
    outArray = [SinOsc.ar(440, 0, 0.2), SinOsc.ar(442, 0, 0.2)];
    Out.ar(out, outArray)
}



defmodule UgenSpec do
  @moduledoc """
  UGens represent calculations with signals. They are the basic building blocks of synth definitions on the server, and are used to generate or process both audio and control signals.
  """
  defstruct ~w[
              class_name

              calculation_rate
              special_index

              inputs_count input_specs_list
              
              outputs_count output_specs_list       
            ]a
end

defmodule InputSpec do
  defstruct ~w[
    index
    index_of_constant
    index_of_ugen_output
  ]a
end

defmodule OutputSpec do
  defstruct ~w[
    calculation_rate
  ]a
end

defmodule VarientSpec do
  defstruct ~w[
    name
    parameter_values_list
  ]a
end

defmodule SynthDefFile do
  @file_version 2

  def file_def(synth_def_list) do
    [
      type_id: {"SCgf", :string},
      file_version: {@file_version, :int32},
      synth_defs_count: {length(synth_def_list), :int16},
      synth_defs: synth_def_list
    ]
  end

  def synth_def_list(synth_defs) do
  end
end
```

```elixir
# %SynthDef{
#   name: "help_notRand",
#   ugen_specs_list: [
#     %UgenSpec{
#       class_name:

#       calculation_rate:

#       special_index:

#       inputs_count:
#       input_specs_list:

#       outputs_count:
#       output_specs_list:    
#     }
#   ]

# }
```

### Synthdef file called 'ambient.synthdef'

```
(
  SynthDef(
	"ambient",
	{ |out|
		Out.ar(out, BrownNoise.ar(0.2));
			
	}
   )
).writeDefFile("/Users/haubie/Development/supercollider", overwrite: true)
```

```elixir
file = "/Users/haubie/Development/supercollider/ambient.scsyndef"
file = "/Users/haubie/Development/supercollider/pink-ambient.scsyndef"
file = "/Users/haubie/Development/supercollider/hoover.scsyndef"
bin_data = File.read!(file)
```

```elixir
bin_data
|> :binary.bin_to_list()
|> Enum.map(fn byte ->
  if byte in 32..126//1 do
    <<byte>>
  else
    byte
  end
end)
|> IO.inspect()
```

```elixir
bin_data
|> :binary.bin_to_list()
|> Enum.map(fn byte ->
  if byte in 32..126//1 do
    <<byte>>
  else
    byte
  end
end)
|> IO.inspect()
```

```elixir
# HEADER
<<
  file_type_id::binary-size(4),
  file_version::big-signed-32,
  num_synth_defs::big-signed-16,
  rest::binary
>> = bin_data

"""
 File type: \t#{file_type_id}
 File version:\t#{file_version}
 Number of synth defs: #{num_synth_defs}
"""
|> IO.puts()

rest
|> :binary.bin_to_list()
|> Enum.map(fn byte ->
  if byte in 32..126//1 do
    <<byte>>
  else
    byte
  end
end)
|> IO.inspect()
```

```elixir
## SYNTHDEF
<<
  synth_name_length::big-integer-8,
  synth_name::binary-size(synth_name_length),
  num_constants::big-integer-32,
  rest_synthdef::binary
>> = rest

"""
  Length of name:\t#{synth_name_length}
  Synth name:\t\t#{synth_name}

  Num of constants:\t#{num_constants}
"""
|> IO.puts()

defmodule Parse do
  def parse_floats(binary, number) do
    parse_floats(binary, number, 0, [])
  end

  def parse_floats(binary, number, const_index, acc) when const_index < number do
    <<constant_value::big-float-32, rest_binary::binary>> = binary

    # IO.puts "i(#{const_index}):\t#{constant_value}"
    constant = {const_index, constant_value |> Float.round(3)}

    parse_floats(rest_binary, number, const_index + 1, [constant] ++ acc)
  end

  def parse_floats(binary, _number, _const_index, acc) do
    {acc |> Enum.sort(), binary}
  end

  def parse_param_name_value_pairs(binary, number) do
    parse_param_name_value_pairs(binary, number, 0, [])
  end

  def parse_param_name_value_pairs(binary, number, count, acc) when count < number do
    <<
      param_name_length::big-integer-8,
      param_name::binary-size(param_name_length),
      param_index_value::big-integer-32,
      rest_binary::binary
    >> = binary

    param = {count, param_name, param_index_value}

    parse_param_name_value_pairs(rest_binary, number, count + 1, [param] ++ acc)
  end

  def parse_param_name_value_pairs(binary, _number, _count, acc) do
    {acc |> Enum.sort(), binary}
  end
end

{constant_values_list, more_binary} = Parse.parse_floats(rest_synthdef, num_constants)

IO.inspect(constant_values_list, label: "List of constants")

<<
  num_params::big-integer-32,
  # parameter_values::big-float-32,
  # num_param_names::big-integer-32,
  # param_name_length::big-integer-8,
  # param_name::binary-size(param_name_length),
  rest_synthdef_params::binary
>> = more_binary

IO.inspect(num_params, label: "Num params")

{param_values_list, more_binary_two} = Parse.parse_floats(rest_synthdef_params, num_params)

IO.inspect(param_values_list, label: "List of params")

<<
  num_param_names::big-integer-32,
  rest_synthdef_params_names::binary
>> = more_binary_two

IO.inspect(num_params, label: "Num param names")

{param_names_and_values_list, more_binary_three} =
  Parse.parse_param_name_value_pairs(rest_synthdef_params_names, num_param_names)

IO.inspect(param_names_and_values_list, label: "List of param names and index values")
```

```elixir
## UGENS

# int32 - number of unit generators (U)
# [ ugen-spec ] * U
# pstring - the name of the SC unit generator class
# int8 - calculation rate
# int32 - number of inputs (I)
# int32 - number of outputs (O)
# int16 - special index
# [ input-spec ] * I
# int32 - index of unit generator or -1 for a constant
# if (unit generator index == -1)
# int32 - index of constant
# else
# int32 - index of unit generator output
# [ output-spec ] * O
# int8 - calculation rate

defmodule Parser do
  def parse_input_spec(binary, number) do
    parse_input_spec(binary, number, 0, [])
  end

  def parse_input_spec(binary, number, count, acc) when count < number do
    <<
      ugen_index::signed-big-integer-32,
      ugen_constant::big-integer-32,
      ugen_output_index::big-integer-32,
      rest::binary
    >> = binary

    input_spec = [
      %{
        count: count,
        ugen_index: ugen_index,
        ugen_constant: ugen_constant,
        ugen_output_index: ugen_output_index
      }
    ]

    parse_input_spec(rest, number, count + 1, input_spec ++ acc)
  end

  def parse_input_spec(binary, _number, _count, acc) do
    {acc, binary}
  end

  def parse_output_spec(binary, number) do
    parse_output_spec(binary, number, 0, [])
  end

  def parse_output_spec(binary, number, count, acc) when count < number do
    <<output_calc_rate::big-integer-8, rest::binary>> = binary
    output_spec = [%{count: count, calculation_rate: output_calc_rate}]
    parse_output_spec(rest, number, count + 1, output_spec ++ acc)
  end

  def parse_output_spec(binary, _number, _count, acc) do
    {acc, binary}
  end

  def parse_ugens(binary, number) do
    parse_ugens(binary, number, 0, [])
  end

  def parse_ugens(binary, number, count, acc) when count < number do
    <<
      ugen_class_name_length::big-integer-8,
      ugen_class_name::binary-size(ugen_class_name_length),
      calculation_rate::big-integer-8,
      num_inputs::big-integer-32,
      num_outputs::big-integer-32,
      special_index::big-integer-16,
      binary_ugen_rest::binary
    >> = binary

    {input_specs, binary_input_specs} = parse_input_spec(binary_ugen_rest, num_inputs)
    {output_specs, binary_output_specs} = parse_output_spec(binary_input_specs, num_outputs)

    ugen = [
      %{
        ugen_class_name_length: ugen_class_name_length,
        ugen_class_name: ugen_class_name,
        calculation_rate: calculation_rate,
        num_inputs: num_inputs,
        num_outputs: num_outputs,
        special_index: special_index,
        input_specs: input_specs,
        output_specs: output_specs
      }
    ]

    parse_ugens(binary_output_specs, number, count + 1, ugen ++ acc)
  end

  def parse_ugens(binary, _number, _count, acc) do
    {acc, binary}
  end
end

rest_synthdef = more_binary_three

<<
  num_unit_gens::big-integer-size(32),
  binary_ugen_rest::binary
>> = rest_synthdef

{ugens, binary} = Parser.parse_ugens(binary_ugen_rest, num_unit_gens)

# """
#   num_unit_gens: #{num_unit_gens}

#   ugen_class_name_length: #{ugen_class_name_length}
#   ugen_class_name: #{ugen_class_name}

#   calculation_rate: #{calculation_rate}
#   num_inputs: #{num_inputs}
#   num_outputs: #{num_outputs}
#   special_index: #{special_index}
# """
# |> IO.puts()
```

```elixir
## INPUT SPEC

# [ input-spec ] * I
# int32 - index of unit generator or -1 for a constant
# if (unit generator index == -1)
# int32 - index of constant
# else
# int32 - index of unit generator output
# [ output-spec ] * O
# int8 - calculation rate

<<
  ugen_index::signed-big-integer-32,
  ugen_constant::big-integer-32,
  ugen_output_index::big-integer-32,
  output_calculation_rate::big-integer-8,
  varients::binary
>> = input_ouput_data

"""
  ugen_index:\t\t#{ugen_index}
  ugen_constant:\t#{ugen_constant}
  ugen_output_index:\t#{ugen_output_index}
  output_calculation_rate:\t#{output_calculation_rate}
"""
|> IO.puts()

varients
```

```elixir
## VARIENTS

# int16 - number of variants (V)
# [ variant-spec ] * V
# pstring - the name of the variant
# [float32] * P - variant initial parameter values

<<
  num_varients::big-integer-16,
  varient_name_length::big-integer-8,
  varient_name::binary-size(varient_name_length),
  varient_params::big-float-32,
  final::binary
>> = varients

"""
  num varients: #{num_varients}

  varient_name_length: #{varient_name_length}
  varient_name: #{varient_name}

  varient_params: #{varient_params}
"""
|> IO.puts()

final
|> :binary.bin_to_list()
|> Enum.map(fn byte ->
  if byte in 32..126//1 do
    <<byte>>
  else
    byte
  end
end)
|> IO.inspect()
```

```elixir
defmodule SynthDef do
  @file_version 2

  def header(num_synth_defs) do
    "SCgf" <> <<@file_version::big-signed-32>> <> <<num_synth_defs::big-signed-16>>
  end

  def synthdef(synth_name, constants \\ []) do
    synth_name <> constants(constants)
  end

  defp constants(constants) do
    num_constants = length(constants)

    const_values =
      constants
      |> Enum.map(fn value -> <<value::big-float-32>> end)
      |> Enum.join()

    <<num_constants::big-signed-32>> <> const_values
  end

  defp parameters(parameter_values, parameter_names) do
    num_parameters = length(parameter_values)

    init_param_values =
      parameter_values
      |> Enum.map(fn value -> <<value::big-float-32>> end)
      |> Enum.join()

    num_parameter_names = length(parameter_names)

    param_names_with_index =
      parameter_values
      |> Enum.with_index()
      |> Enum.map(fn name, index -> name <> <<index::big-signed-32>> end)
      |> Enum.join()

    <<num_parameters::big-signed-32>> <> init_param_values <> param_names_with_index
  end

  defp ugenspec(ugen_class_name, calculation_rate, special_index, input_specs, output_specs) do
    num_in = length(input_specs)
    num_out = length(output_specs)

    # input_spec_list = 
    #   parameter_values
    #   |> Enum.with_index()
    #   |> Enum.map(
    #     fn name, index -> name <> <<index::big-signed-32>> end
    #   ) 
    #   |> Enum.join()

    ugen_class_name <>
      <<calculation_rate::big-signed-8>> <>
      <<num_in::big-signed-32>> <>
      <<num_out::big-signed-32>> <>
      <<special_index::big-signed-16>>

    # [ input-spec ] * I
    #   int32 - index of unit generator or -1 for a constant
    #   if (unit generator index == -1)
    #     int32 - index of constant
    #   else
    #   int32 - index of unit generator output
    # [ output-spec ] * O
    # int8 - calculation rate
  end
end
```

```elixir
bytecode = SynthDef.header(1) <> SynthDef.synthdef("sonic-pi-beep", [1, 2, 3])
```

```elixir
dir = "/Users/haubie/Development/supercollider"

{:ok, file} = File.open(dir <> "/test.synthdef", [:write])
IO.binwrite(file, bytecode)
File.close(file)
```
